var e={d:(t,r)=>{for(var s in r)e.o(r,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:r[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{QR:()=>n,Di:()=>r,PP:()=>c,S7:()=>s,b4:()=>a,SX:()=>o,KA:()=>i,rd:()=>l,OB:()=>f,Kr:()=>h,vb:()=>d,an:()=>m});class r extends Error{constructor(){super(...arguments),this.name="ApiBaseError"}}class s extends r{constructor(e,t="ApiDomError",r){super(e,r),this.name=t}}class a extends r{constructor(e,t,r){super(e,r),this.status=t,this.name="ApiHttpStatusError"}}class n extends a{constructor(e,t){super(e,401,t),this.name="ApiAuthError"}}class o extends r{constructor(){super(...arguments),this.name="ApiResponseError"}}class i extends o{constructor(e,t,r){super(e,r),this.error=t,this.name="ApiStreamError"}}class c extends o{constructor(e,t,r){super(e,r),this.responseHeader=t,this.name="ApiCommonStatusError"}}class p extends TransformStream{#e="";#t=!1;#r=!1;#s=e=>e;constructor(e){super({transform:(e,t)=>this.#a(e,t),flush:e=>this.#a("\r\n",e)}),this.#t=e?.allowCR??!1,this.#r=e?.returnEmptyLines??!1,this.#s=e?.mapperFun??this.#s}#a(e,t){for(e=this.#e+e;;){const r=e.indexOf("\n");if(this.#t){const s=e.indexOf("\r");if(-1!==s&&s!==e.length-1&&(-1===r||r-1>s)){const r=this.#s(e.slice(0,crOrLfIndex));(this.#r||r)&&t.enqueue(r),e=e.slice(s+1);continue}}if(-1===r)break;{let s=r;"\r"===e[r-1]&&s--;const a=this.#s(e.slice(0,s));(this.#r||a)&&t.enqueue(a),e=e.slice(r+1)}}this.#e=e}}const u=async e=>{const t={},r={method:e.method,headers:t};let o;void 0!==e.payload&&(r.body=JSON.stringify(e.payload),t["Content-Type"]="application/json"),void 0!==e.authInfo&&(t["Grpc-Metadata-username"]=e.authInfo.username,t["Grpc-Metadata-token"]=e.authInfo.token),void 0!==e.headers&&Object.assign(t,e.headers),void 0!==e.abortSignal&&(r.signal=e.abortSignal);try{o=await fetch(e.baseUrl+e.path,r)}catch(e){if(e instanceof DOMException)throw new s(e.message,e.name);throw new s("unexpected fetch result")}if(401===o.status)throw new n("failed to authenticate: token might be invalid");if(!o.ok)throw new a("failed to fetch response: invalid http status code",o.status);return o},h=async e=>{const t=await u(e);try{return await t.json()}catch(e){throw new o("failed to parse as json")}},d=async function*(e){const t=(await u(e)).body.pipeThrough(new TextDecoderStream).pipeThrough(new p).getReader();for(;;){const e=await t.read();if(e.done)break;let r;try{r=JSON.parse(e.value)}catch(e){throw new o("failed to parse as json")}if(void 0!==r.error)throw new i("response has an error",r.error);yield r}},l=async e=>{const t=await h(e);let r;try{r=t.responseHeader.status}catch(e){throw new o("failed to get resp.responseHeader.status")}if(0!==r)throw new c(`invalid status: ${r}`,t.responseHeader);return t},f=async function*(e){for await(const t of d(e)){let e;try{e=t.result.responseHeader.status}catch(e){throw new o("failed to get chunk.result.responseHeader.status")}if(0!==e)throw new c(`invalid status: ${e}`,t.result.responseHeader);yield t}},m=async e=>{const t=[];for await(const r of e)t.push(r);return t};var w=t.QR,y=t.Di,E=t.PP,b=t.S7,A=t.b4,S=t.SX,v=t.KA,x=t.rd,g=t.OB,O=t.Kr,R=t.vb,H=t.an;export{w as ApiAuthError,y as ApiBaseError,E as ApiCommonStatusError,b as ApiDomError,A as ApiHttpStatusError,S as ApiResponseError,v as ApiStreamError,x as fetchJson,g as fetchJsonStream,O as fetchRawJson,R as fetchRawJsonStream,H as streamToArray};
//# sourceMappingURL=index.js.map